image: docker:24.0.6-cli
options:
  docker: true

definitions:
  steps:
    - step: &init
        image: alpine:3.20
        name: Init (capture deployment env)
        script:
          - apk add --no-cache bash coreutils
          - set -euo pipefail
          - echo "SAMPLE_VAR_KEY_1 ${SAMPLE_VAR_KEY_1}"
          # branch → deploy env
          - |
            if [ "$BITBUCKET_BRANCH" = "main" ]; then
              DEPLOY_ENV="prod"
            elif [ "$BITBUCKET_BRANCH" = "staging" ]; then
              DEPLOY_ENV="staging"
            else
              echo "❌ Unsupported branch $BITBUCKET_BRANCH"; exit 1
            fi
            echo "$DEPLOY_ENV" > .deploy_env

          # capture "almost everything" except CI internals
          # (add/remove patterns as you see fit)
          - >
            env | grep -vE '^(BITBUCKET_|PIPES_|CI=|SHELL=|PWD=|HOME=|PATH=|SHLVL=|_=|HOSTNAME=|DOCKER_HOST=)'
            > .ci_env
          - echo "DEPLOY_ENV=$(cat .deploy_env)" >> .ci_env
        artifacts:
          - .deploy_env
          - .ci_env

    - step: &build-push
        name: Build & Push (backend)
        services: [docker]
        script:
          - apk add --no-cache aws-cli jq bash
          - set -euo pipefail

          # source shared deployment env (allow unset during source)
          - set +u; set -a; source .ci_env; set +a; set -u

          # required
          - '[ -n "${AWS_REGION:-}" ] || { echo "AWS_REGION is required"; exit 1; }'
          - '[ -n "${PROJECT:-}" ]    || { echo "PROJECT is required"; exit 1; }'

          # image + repo
          - export DOCKER_DEFAULT_PLATFORM=linux/amd64
          - REPO_NAME="${PROJECT}-${DEPLOY_ENV}-backend"
          - VERSION=$(cat VERSION)
          - AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          - IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${REPO_NAME}:${VERSION}"

          # ECR login + build + push
          - aws ecr get-login-password --region "${AWS_REGION}" | docker login --username AWS --password-stdin "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          - export DOCKER_BUILDKIT=0 COMPOSE_DOCKER_CLI_BUILD=0 IMAGE_URI
          - docker compose -f docker-compose.build.yml build
          - docker push "${IMAGE_URI}"

          # hand off to deploy
          - echo "${VERSION}" > .version
        artifacts:
          - .deploy_env
          - .ci_env
          - .version

    - step: &deploy
        image: node:20-alpine
        name: Deploy (CDK)
        script:
          - apk add --no-cache aws-cli bash jq
          - set -euo pipefail

          # source shared deployment env (allow unset during source)
          - set +u; set -a; source .ci_env; set +a; set -u
          - echo "SAMPLE_VAR_KEY_1=${SAMPLE_VAR_KEY_1:-<unset>}"  # sanity check

          - DEPLOY_ENV=$(cat .deploy_env)
          - VERSION=$(cat .version)

          - '[ -n "${AWS_REGION:-}" ] || { echo "AWS_REGION is required"; exit 1; }'
          - '[ -n "${PROJECT:-}" ]    || { echo "PROJECT is required"; exit 1; }'

          - STACK_NAME="${PROJECT}-backend-${DEPLOY_ENV}"
          - echo "🛠 Deploying to stack ${STACK_NAME} (env ${DEPLOY_ENV}) with version ${VERSION}"

          # ensure infra deps are installed
          - cd infra
          - npm ci
          - npx cdk --version
          - npx cdk context --clear || true
          - npx cdk deploy \
              --require-approval never \
              -c stage="${DEPLOY_ENV}" \
              -c version="${VERSION}"

pipelines:
  branches:
    main:
      - step:
          <<: *init
          deployment: prod      # deployment tag ONLY here
      - step: *build-push
      - step: *deploy
    staging:
      - step:
          <<: *init
          deployment: staging   # deployment tag ONLY here
      - step: *build-push
      - step: *deploy
