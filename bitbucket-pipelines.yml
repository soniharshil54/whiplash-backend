image: docker:24.0.6-cli
options:
  docker: true

definitions:
  steps:
    - step: &build-push
        name: Build & Push (frontend)
        services: [docker]
        script:
          - apk add --no-cache aws-cli jq bash
          - set -euo pipefail

          # branch ‚Üí deploy env
          - |
            if [ "$BITBUCKET_BRANCH" = "main" ]; then
              DEPLOY_ENV="prod"
            elif [ "$BITBUCKET_BRANCH" = "staging" ]; then
              DEPLOY_ENV="staging"
            else
              echo "‚ùå Unsupported branch $BITBUCKET_BRANCH"; exit 1
            fi
            echo "$DEPLOY_ENV" > .deploy_env

          # required
          - '[ -n "${AWS_REGION}" ] || { echo "AWS_REGION is required"; exit 1; }'
          - '[ -n "${PROJECT}" ]    || { echo "PROJECT is required"; exit 1; }'

          # image + repo
          - export DOCKER_DEFAULT_PLATFORM=linux/amd64
          - REPO_NAME="${PROJECT}-${DEPLOY_ENV}-frontend"
          - VERSION=$(cat VERSION)
          - AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          - IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${REPO_NAME}:${VERSION}"

          # ECR login + build (no BuildKit) + push
          - aws ecr get-login-password --region "${AWS_REGION}" | docker login --username AWS --password-stdin "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          - export DOCKER_BUILDKIT=0
          - export COMPOSE_DOCKER_CLI_BUILD=0
          - export IMAGE_URI
          - docker compose -f docker-compose.build.yml build
          - docker push "${IMAGE_URI}"

          # hand off to deploy
          - echo "${VERSION}" > .version
        artifacts:
          - .deploy_env
          - .version

    - step: &deploy
        name: Deploy (update FrontendImageTag)
        script:
          - apk add --no-cache aws-cli jq bash
          - set -euo pipefail

          - DEPLOY_ENV=$(cat .deploy_env)
          - VERSION=$(cat .version)

          # required
          - '[ -n "${AWS_REGION}" ] || { echo "AWS_REGION is required"; exit 1; }'
          - '[ -n "${PROJECT}" ]    || { echo "PROJECT is required"; exit 1; }'

          - STACK_NAME="${PROJECT}-backend-${DEPLOY_ENV}"
          - echo "üõ† Deploying to stack ${STACK_NAME} (env ${DEPLOY_ENV}) with version ${VERSION}"

          # wait if stack busy
          - |
            STATUS=$(aws cloudformation describe-stacks --stack-name "${STACK_NAME}" --query "Stacks[0].StackStatus" --output text 2>/dev/null || true)
            if [ -z "$STATUS" ] || [ "$STATUS" = "STACK_NOT_FOUND" ]; then
              echo "‚ùå Stack ${STACK_NAME} not found. Create it once from infra (cdk deploy)."; exit 1
            fi
            if [ "$STATUS" = "CREATE_IN_PROGRESS" ]; then
              aws cloudformation wait stack-create-complete --stack-name "${STACK_NAME}"
            elif [ "$STATUS" = "UPDATE_IN_PROGRESS" ] || [ "$STATUS" = "UPDATE_COMPLETE_CLEANUP_IN_PROGRESS" ]; then
              aws cloudformation wait stack-update-complete --stack-name "${STACK_NAME}"
            fi

          # image-only update; envs are baked at build time
          - |
            set +e
            cdk context --clear
            cdk deploy \
              --require-approval never \
              --context version="${VERSION}"

pipelines:
  branches:
    main:
      - step:
          <<: *build-push
          deployment: prod    # only here
      - step:
          <<: *deploy         # no deployment tag

    staging:
      - step:
          <<: *build-push
          deployment: staging # only here
      - step:
          <<: *deploy         # no deployment tag
